<!DOCTYPE html>
<html>

<head>
  
<meta charset='utf-8'>
<meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- CSS -->
<link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
<link rel="stylesheet" type="text/css" href="/saffire-docs/stylesheets/stylesheet.css" media="screen" />
<link rel="stylesheet" type="text/css" href="/saffire-docs/stylesheets/pygment_trac.css" media="screen" />
<link rel="stylesheet" type="text/css" href="/saffire-docs/stylesheets/print.css" media="print" />

<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<title>Saffire Phases</title>


</head>

<body>
  <div id="container">
      <img src="http://saffire-lang.org/images/logo.png" align="right">
    <div class="inner">
      <header>
        <h1><a href="http://saffire.github.com/"></a></h1>
      </header>

      <section id="main_content">
        <header class="post-header">
    <h1>Saffire Phases</h1>
    <p class="meta">Jan 1, 2015 • Joshua Thijssen</p>
</header>

<h2 id="phases">Phases</h2>
<p>Saffire runs in a few different phases, where some of the phases are not yet implemented, some phases are “merged” together, and some phases should be obsoleted in the near future.</p>

<ul>
  <li>Phase 1: Lexing tokens</li>
  <li>Phase 2: Parsing tokens to correspond with Saffire grammar</li>
  <li>Phase 3: converting AST into ASM</li>
  <li>Phase 4: converting ASM into bytecode</li>
  <li>Phase 5: execute bytecode through the Saffire Virtual Machine</li>
</ul>

<h2 id="phase-1-lexing">Phase 1: Lexing</h2>
<p>The first phase of getting a Saffire userland application to run is through lexing. This is the process of converting text (a file with saffire code in it) to a long list of known tokens. For instance, if your code consists of simply <code>import foo;</code>, it will emit three tokens: <code>T_IMPORT</code> <code>&lt;identifier&gt;</code> and <code>;</code>. The lexer knows about keywords (like the string <code>import</code>), but also about brackets, operators etc. It knows about comments (either <code>/* .. */</code> or <code>//</code>) and strings (with single quotes or double quotes), and it knows that whenever the word <code>"import"</code> is found withing quotes, it is a string instead of the token <code>T_IMPORT</code>. However, it does not know anything about what <code>T_IMPORT</code> does. It does not know that T_IMPORT must be followed by an identifier and ended with a <code>;</code>. This is the parsers job. </p>

<p>For the tokening, Saffire uses flex. And this code can be found in <code>/src/components/compiler/saffire.l</code>. There is some additional complexity in it, for instance, a <code>/</code> can have different meaning based on context. For instance, it can be used for regular expressions (<code>if foo ~= /fo+/</code>), or it can be seen as a divider operator (<code>a = 10 / 5;</code>). This is where the two different states come from named <code>st_div</code> and <code>st_regex</code>. </p>

<p>There is some additional (C) code present in this file to help with lexing through the Saffire REPL system.</p>

<p>The <code>saffire.l</code> file will be compiled (through the flex application) into a <code>lex.yy.c</code>. This file will be compiled into Saffire and has the functionality that creates the stream of input tokens (lexemes) that the parser in the next phase can work with.</p>

<h2 id="phase-2-parsing">Phase 2: Parsing</h2>
<p>Once we have established a stream of tokens, we can actually tell Saffire what they mean, and how they should be ordered. For instance, that an import statement (starting with the <code>T_IMPORT</code> token) must be present before any other code, and that after a “switch” must come a opening parenthesis <code>switch a</code> is wrong, while <code>switch (a)</code> is correct syntax.</p>

<p>This parsing is done through <code>bison</code>, and is often-used in combination with <code>flex</code>. The parse-rules are defined in <code>src/components/compiler/saffire.y</code>. </p>

<p>The parsing has a few purposes:</p>

<ol>
  <li>It will check if your Saffire code is syntaxily correct (<code>import foo;</code> would be ok, but <code>foo import;</code> not.</li>
  <li>It will convert the code into an <code>Abstract Syntax Tree</code>, which makes it easier later on to work with.</li>
  <li>
    <p>It can do some (rudimentary) checks that are sometimes too hard to setup as real bison rules. </p>

    <p>For instance, when creating the roles on function visibility, we accept all modifiers (final, public, private, abstract, static etc). But not all combinations make sense or are allowed: <code>final abstract</code> is pretty useless, so is <code>protected public</code> etc. On occasion, the bison rules will call functions like <code>parser_validate_flags()</code> and <code>parser_validate_property_modifiers()</code> that will do these checks. These functions are defined in <code>src/component/compiler/parser_helpers.c</code>.</p>

    <p>It’s got many other helpfull functions like <code>parser_switch_default()</code>, which checks if you haven’t added two <code>default</code> elements within a switch statement for instance. </p>

    <p>Another important function is the <code>parser_write_check()</code> that checks if an element is writable (ie: it’s a variable or a subscribt (<code>a[1]</code> or even <code>a[]</code>). This allows to quickly check if you haven’t done anyhting like <code>4 = 6;</code> as you cannot store the number <code>6</code> into <code>4</code>, (but <code>a = 6;</code> would be ok, as <code>a</code> is a writable variable).</p>
  </li>
</ol>

<h3 id="abstract-syntax-tree">Abstract Syntax Tree</h3>
<p>As soon as we have defined a rule, and the tokens follow that rule, we can setup an <code>Abstract Syntax Tree</code> (<code>AST</code>). This is a tree structure that follows Saffire rules, where everything is abstracted into defined elements. For instance, when we encounter an “import” statement within the tree, we always know that that statement hase 3 children underneat, being a class, an alias and a module. With this information it makes it much easier to write a system that actually can interpret the parsed saffire code later on. An AST is simply in setup, and does not contain any unneeded information like ‘;’, comments, comma’s, parentesis etc. It’s possible to generate an AST from Saffire code, but it’s harder to generate Saffire code from an AST, although it is possible (but it will never be exactly the same as the original source code).</p>

<p>Another benefit of AST’s is that you can perform all kind of tricks to them. One of them is that each node in the AST has a line number on where that node was inside the actual source code. For instance, if you had an import statement on the first line of your code, the corresponding AST import element would have line number one. If something goes wrong, for instance, when the import module could not be found, it would be easier to generate an error like: <code>"Error on line 1: cannot import module 'foo'"</code>.</p>

<p>It’s possible within Saffire to generate an AST and graphically display it with the “<code>saffire compile bytecode --dot</code>” command. This creates a graphviz DOT file which can be converted to an image. It was used during the construction of the parser, but never removed. Do not use on very large programs, as many elements will be present in the AST, but on very small programms (10-20 lines), it’s a nice overview of your code in an AST representation.</p>

<h4 id="ast-elements">AST elements</h4>
<p>Each element within the AST is a <code>t_ast_element</code>, which by itself is a large union/structure (defined in <code>include/saffire/compiler/ast_nodes.h</code>. There are a fixed number of ast elements: string, numerical, identifier, class, operator etc, each element type has it’s own set of data (the string ast element has only a <code>char *value</code>, while the numerical ast element as a <code>int value</code>. More complex elements like the operator element has an <code>oper</code>, which defines which operator is used (add, sub, div, mul, shr etc), the number of operators in <code>nops</code> and a list with <code>nops</code> ast elements. </p>

<p>Each ast element has some global data as found in the <code>t_ast_element</code> structure: it’s <code>type</code>, <code>flags</code> (i think this property is obsolete), <code>lineno</code> the current line number in the source file for this element, and <code>grouping</code>, which, if set to 1, tells that this element is a container with other elements (so we can add elements to a group without specifiying that this can only be done to all the specific grouping separately).</p>

<p>Ultimately, the bison file (<code>saffire.y</code> will go over the rules, and build up the AST-tree. At the end of the parsing, a single root ast_element will be generated under which all other nodes will fall. Each bison rule will most like create a new ast element (or elements), which then gets added by bison to the tree. Creating these ast elements are done by the <code>ast_*</code> functions that can be found in <code>saffire.y</code>. These functions are located in <code>src/component/compiler/ast_nodes.c</code>.</p>

<h2 id="phase-3-asm">Phase 3: ASM</h2>
<p>Once completed, the AST can be used for multiple purposes, but its main purpose is to be converted to bytecode. However, due to some serious issues (which still aren’t solved), this AST-&gt;bytecode conversion does not work properly and an additional step is needed. This step is to convert the AST to assembler (ASM). This ASM format are just simple sequental lines telling what must be done.</p>

<p>For instance, when encountering a string AST element, it will “emit” a line similar to “<code>VM_LOAD_ID $1</code>”, where <code>$1</code> is the number on where that given string is found in the bytecode. This is another reason why using an AST is easier: you can start by scanning the whole tree to find all the constant string values and numerical values, and assign them a number. For instance “foo” could become <code>$1</code>, so when the system emits <code>VM_LOAD_ID $1</code>, the virtual machine knows that it needs to load the string “foo”.</p>

<p>This whole “walking” of the AST tree and emitting assembler lines is done in the file <code>src/component/compiler/ast_to_asm.c</code>.</p>

<p>But things can be a bit complex. For instance, when encountering an identifier element (like the <code>a</code> in <code>a = 5;</code>, a few things need to be known: this <code>a</code>, do we need to load the information found in <code>a</code>, or are we storing something in <code>a</code>?. In the case of <code>a = 5</code>, we are storing something into <code>a</code>. However, in <code>b = a</code>, we must load the value of <code>a</code> (and store it in <code>b</code>). So we need to keep a context that tells us if we are currently loading or storing something. This means that when emitting, it can know if it needs to emit either a <code>VM_LOAD_ID</code> or <code>VM_STORE_ID</code>.</p>

<p>Creating this assembler is actually pretty hard. This is deliberatly done, because it also means that the virtual machine can stay relatively simple (stupid, even). Since more time is spend in the VM than “compiling” the AST into ASM (and bytecode), it makes sense to do it this way.</p>

<p>As we will see later, it means that the VM does not do much. There are no while and for statements. There isn’t really a “real” if-statement. It’s just loading, storing and jumping that the VM does (which in fact, is what a CPU does as well!).</p>

<p>When the whole AST is walked, the code is completely converted into “assembler”. However, this is not a textual representation yet. It is possible to create one by on the commandline by using the command: <code>saffire bytecode compile --text</code>. This will create a <code>.sfa</code> file which stands for Saffire assembly. However, saffire cannot run these files, there are only for output / experimental purposes (mostly to check the generation of bytecode and execution through the VM machine).</p>

<p>The actual data structure used are “frames”. It starts with the “main” frame, which is the start of the application. Each method body is a seperate frame so each method is represented by its own assembler-code and supporting data (like the symbol table that keeps track on which variable and constant is which number in the code). </p>

<h2 id="phase-4-bytecode">Phase 4: Bytecode</h2>
<p>Unfortunately, we cannot generate bytecode directly, but need an intermediate step from the assembler. But, with the assembler lines, we can generate bytecode. </p>

<p>There is a file called <code>src/components/compiler/ast_to_bytecode.c</code>, that optimistically is empty. It should contain the functionality to convert AST straight away.</p>

<p>For now, the bytecode is generated by <code>src/component/compiler/output/asm.c</code>, the <code>assembler()</code> method. This method will take the collection of frames as generated by <code>ast_to_asm</code>, and generate bytecode for it. Most of this work is actually done by <code>convert_frames_to_bytecode()</code> in the <code>src/component/compiler/bytecode/marshal.c</code> file. It will create the bytecode based on the assembler code, and the supporting data like the constants, strings and identifiers found in the given frame. Besides these elements, a line number table is stored within the bytecode. Basically it is an (efficient) lookup table that can quickly tell that when i’m in the bytecode on position 98, to which original line in the saffire source it corresponds (so this information was present in the AST, was copied over to the ASM, and is ultimately stored in the bytecode file). This allows to do: “error on line 6”, even though the virtual machine found an error somewhere in the bytecode and have no idea what “line 6” actually is.</p>

<p>We will talk about what actually bytecode during the VM phase. For now, we have created a “compact” structure with all the information needed for the virtual machine to execute what was intended in the actual source file. Basically, as soon as the AST has been generated, the original saffire source file is never needed anymore and could be removed.</p>

<p>This is a feature of Saffire: it allows you to run (precompiled) bytecode files without the original source files be present. This is NOT however, a way to protect your original code, as it is possible to read a bytecode file to figure out what’s going on, but it does mean that the whole process of lexing, parsing, converting to AST and ASM and bytecode can be skipped. This could drastically speed up processing! </p>

<p>Once a bytecode structure has been generated, it’s possible for Saffire to save this file on disk in the form of <code>&lt;filename&gt;.sfc</code>. It’s stands for saffire compiled (code). If a corresponding sfc file is found, saffire will read that file and start executing immediately. It can detect if the sfc file is out-of-date (it stores the modification time of the saffire source file (<code>.sf</code>) inside the <code>.sfc</code> file, so when the <code>.sf</code> time is newer than the one recorded in the <code>.sfc</code> file, it means that the user has changed the saffire source code, and a new <code>.sfc</code> must be compiled.</p>

<p>Another benefit of using <code>.sfc</code> files is that they can be signed by a GPG key. This way, it’s easy to authenticate code and to make sure that it’s genuine without anyone else being able to have it modified. For instance, it’s possible to sign your binary, (and maybe even to sign your source code file as well?). If the user key is trusted in your GPG keychain, it will automatically run the code (or the import). If not, it will deny it. This way, you can always assume trusted code (especially useful when dealing with third party modules and extensions).</p>

<h2 id="phase-x-the-missing-optimizer">Phase X: the missing optimizer</h2>
<p>Normally, we would skip the “assembler” phase, and go directly from AST to bytecode. But even with the intermediate assembler, the actual generated bytecode is still pretty stupid. It will just emit commands without checking any context. It’s quite possible that the following would be emitted:</p>

<pre><code>VM_LOAD_ID $1
VM_LOAD_ID $1
</code></pre>

<p>Where both statement are generated by different AST elements. In this case, (provided we cannot jump directly to the second statement through a label), we could remove the second statement, and change it into a <code>VM_DUP_TOP</code>, which creates a new reference to the last element on the stack:</p>

<pre><code>VM_LOAD_ID $1
VM_DUP_TOP
</code></pre>

<p>This is much faster, as create a new reference on the stack is simply copying an address location, while an extra <code>VM_LOAD_ID</code> consist of looking up the <code>$1</code> into the symbol table, and then copying the reference. Sure, it might not be the LARGEST performance benefit ever, but a lot of small optimizations like these can result in a big performance boost.</p>

<p>Another example:</p>

<pre><code>    VM_POP_TOP
    VM_JUMP_ABSOLUTE  @label3
label3:
    VM_LOAD_ID $1
</code></pre>

<p>In this case, the <code>VM_JUMP_ABSOLUTE</code>, only jumps to the next line, which will be automatically executed anyway. Instead of executing the jump-statement, we can safely remove it:</p>

<pre><code>    VM_POP_TOP
    // removed
label3:
    VM_LOAD_ID $1
</code></pre>

<p>It saves a use-less jump and some VM processing time.</p>

<p>These kind of savings are done through a so-called peephole optimizer: a system that simply checks a small part (the peephole or window) of the code, and graduately shift the window up. Each time, it will go over a set of optimizations and sees if it can optimize things. This again, will keep the assembler/bytecode generator fairly simple without knowing too much about surrounding context, and let the optimizer still be able to optimize some of its code later on.</p>

<h2 id="phase-5-the-vm">Phase 5: The VM</h2>
<p>Once bytecode is loaded, it can be fed into the virtual machine. This is the “heart” of Saffire and is what actually makes things go (voom). In essence, it’s a computer inside a computer (hence, virtual machine), that deals with it’s own way of I/O, processing, error handling but with the occasional input / output to the real machine (for instance, to read files from disk, to output text etc).</p>

<p>The virtual machine is a simple system that deals with a (small) set of operators, and possible a number operands. Each operator is a simple instruction (although some are a bit more complicated) that does something. Most of the instructions deal with the virtual machines stack: this is a simple structure that can hold a number of elements. Some instructions pushes something onto this stack (for intance, the <code>VM_LOAD_ID</code> gets an identifier and pushes this onto the stack, while others will pop values from the stack, does some magic with it and pushes something else back onto the stack.</p>

<p>A simple Saffire example <code>a = 3 + 6;</code> will convert to the following bytecode (possibly):</p>

<pre><code> VM_LOAD_CONST $1
 VM_LOAD_CONST $2
 VM_OPERATOR   #1
 VM_STORE_ID   $5
</code></pre>

<p>The <code>VM_LOAD_CONST</code> will load a constant (fixed strings and numerical values for instance) and pushes it onto the stack. The <code>$1</code> is generated by the assembler/bytecode and represents in this case the number 3 (it could have placed it somewhere else, like <code>$6</code>, but in this case it was <code>$1</code>. So after this, the stack has an numerical object with the value 3.</p>

<p>The second <code>VM_LOAD_CONST</code> takes <code>$2</code>, which is the number <code>6</code> (again, could be a different identifier). Now, two numerical elements are on the stack.</p>

<p>the <code>VM_OPERATOR</code> method will take 1 operand, in this case an IMPLICIT 1 (the <code>#</code> makes it implicit, indiciting it’s actually 1, not variable <code>$1</code>). The <code>VM_OPERATOR</code> call knows that the code <code>1</code> means “addition”, and that it requires two operands. Thus, it will pop two elements from the stack (the ones we just pushed), adds them (through the <code>__add()</code> method, and possible through <code>__coerce()</code>, but we get to there later), and stored the result back onto to the stack. Now, the stack should contain the numerical object with value 9, as the two others are popped by the vm_operator call.</p>

<p>Now, we call <code>VM_STORE_ID $5</code>, which pops an element from the stack, and stores it inside the given identifier. <code>$5</code> in this case represents the <code>a</code>.</p>

<p>This is pretty much what the vm machine does: simple instructions doing simple tasks. All the complex work (converting an <code>if-else</code> or a more complex <code>foreach()/else</code> loop are all broken down into small vm instructions.</p>

<p>The whole VM machine can be found in <code>src/components/vm/vm.c</code>.</p>


      </section>
      <footer>
        
tactile-theme is maintained by <a href="https://github.com/jasonlong">jasonlang</a><br/>
jekyll-tactile-theme is maintained by <a href="https://github.com/ankur-gupta">ankur-gupta</a><br/>

      </footer>
    </div>
  </div>
</body>

</html>
