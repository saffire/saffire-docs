<!DOCTYPE html>
<html>

<head>
  
<meta charset='utf-8'>
<meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- CSS -->
<link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
<link rel="stylesheet" type="text/css" href="http://saffire.github.com/saffire-docs/stylesheets/stylesheet.css" media="screen" />
<link rel="stylesheet" type="text/css" href="http://saffire.github.com/saffire-docs/stylesheets/pygment_trac.css" media="screen" />
<link rel="stylesheet" type="text/css" href="http://saffire.github.com/saffire-docs/stylesheets/print.css" media="print" />

<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<title>General Functionality</title>


</head>

<body>
  <div id="container">
      <img src="http://saffire-lang.org/images/logo.png" align="right">
    <div class="inner">
      <header>
        <h1><a href="http://saffire.github.com/saffire-docs/"></a></h1>
      </header>

      <section id="main_content">
        <header class="post-header">
    <h1>General Functionality</h1>
    <p class="meta">Jan 1, 2015 • Joshua Thijssen</p>
</header>

<h1 id="general-functionality">General functionality</h1>
<p>There are many support functionality within Saffire. Mostly based in the <code>src/components/general</code> directory.</p>

<ul>
  <li>Hashtables / hashmaps</li>
  <li>Base64 encode/decode</li>
  <li>Bzip2 compressor</li>
  <li>Double linked lists (DLL)</li>
  <li>Mutex and semaphores</li>
  <li>Output handling</li>
  <li>Option parsers</li>
  <li>Path handling</li>
  <li>Stacks based on DLL’s</li>
  <li>String functionality</li>
  <li>Unicode (UTF8) functionality</li>
</ul>

<h2 id="hash-tables">Hash tables</h2>
<p>A hash table (<code>src/components/general/hash.c</code>) is a way to simply create hash tables. They are used a lot within Saffire, inside core objects, and even Saffire’s userland hash class is nothing more than a wrapper around a hash table.</p>

<p>Creating and using a hashtable is easy:</p>

<pre><code> t_hash_table *ht = ht_create();
 ht_add_str(ht, "foo", "bar");
 
 char *value = ht_find_str(ht, "foo");
 printf("%s\n", value); // bar
</code></pre>

<p>By default, whatever you store inside a hash-table is a <code>void *</code>, so you have to be careful storing numerical values, as numerical values can be larger than a pointer address (we still need ot make sure this all works correctly in a platform / compiler agnostic way).</p>

<p>We can store anything we like (it’s up to the caller to make sure it knows what it can expect as value), but there are a few different ways to store keys. A key could either be a string, a numerical value, or an object.</p>

<p>To make things more generic, one must use a <code>t_hash_key</code> structure to define the actual key, but to make things more comfortable, there are <code>ht_add_str</code>, <code>ht_add_num</code>, and <code>ht_add_obj</code> methods that will deal with this so you won’t have to.</p>

<p>Iterating a hashtable is possible too:</p>

<pre><code>t_hash_iter iter;
ht_iter_init(&amp;iter, ht);

while (ht_iter_valid(&amp;iter)) {
    t_hash_key *k = ht_iter_key(&amp;iter);
    t_object *v = (t_object *)(ht_iter_value(&amp;iter));
    
    ht_iter_next(&amp;iter);
}
</code></pre>

<p>Since iteration data is located within the t_hash_iter structure, it’s possible to have multiple iterations independently and interwoven. However, there could be issues when hashtables are modified during iteration.</p>

<h2 id="doubly-linked-lists">Doubly Linked Lists</h2>
<p>DLLs are simple data structure that are fast for sequential reads. They again are used a lot in the core, and the tuple userland class uses this structure internally.</p>

<pre><code>t_dll *dll = dll_init();
dll_append(dll, "foo");
dll_append(dll, "bar");
</code></pre>

<p>There are additional functions to insert (quickly) in different spots with the help of t_dll_element values.</p>

<p>Iterating can be done through some simple macro’s:</p>

<pre><code>t_dll_element *e = DLL_HEAD(my_dll);
while (e) {
   char *s = e-&gt;data.p;
   
   e = DLL_NEXT(e);
}
</code></pre>

<p>An element uses either <code>e-&gt;data.p</code> for pointers, and <code>e-&gt;data.l</code> for numerical values. Again, it’s imperative that the called knows what is stored.</p>


      </section>
      <footer>
        
tactile-theme is maintained by <a href="https://github.com/jasonlong">jasonlang</a><br/>
jekyll-tactile-theme is maintained by <a href="https://github.com/ankur-gupta">ankur-gupta</a><br/>

      </footer>
    </div>
  </div>
</body>

</html>
